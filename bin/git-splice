#!/bin/bash
#
# git-splice - splice commits into/out of current branch
# Copyright (c) 2016 Adam Spiers
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------
#
# Non-interactively splice branch by removing a range of commits from
# within the current branch and/or cherry-picking a range of commits
# into the current branch.
#
# If removal and cherry-picking are performed from the same invocation,
# cherry-picking starts from the point of removal.
#
# N.B. Obviously this command rewrites history!  As with git rebase,
# you should be aware of all the implications of history rewriting
# before using it.  (And actually this command is just a glorified
# wrapper around git rebase -i.)
#
# Examples:
#
#   # Remove commits A..B from the current branch
#   git splice A..B
#
#   # Remove commit A from the current branch
#   git splice A^!
#
#   # Remove commits A..B from the current branch, and cherry-pick
#   # commits C..D at the same point
#   git splice A..B C..D
#
#   # Cherry-pick commits C..D, splicing them in just after commit A
#   git splice A C..D
#

me=`basename $0`
git_dir=`git rev-parse --git-dir` || exit 1
splice_dir="$git_dir/splice"
base_file="$splice_dir/base"
branch_file="$splice_dir/branch"
insert_todo="$splice_dir/insert-todo"
remove_todo="$splice_dir/remove-todo"
TMP_BRANCH="tmp/splice"

main () {
    parse_opts "$@"

    if [ -n "$abort" ] || [ -n "$continue" ] || [ -n "$rebase_edit" ]; then
        ensure_splice_in_progress
    else
        # Needs to happen before parse_args(), otherwise the in-flight
        # files will already exist.
        ensure_splice_not_in_progress
    fi

    mkdir -p "$splice_dir"
    parse_args "${ARGV[@]}"

    if [ -n "$rebase_edit" ]; then
        # We're being invoked by git rebase as the rebase todo list editor,
        # rather than by the user.  This mode is for internal use only.
        rebase_edit
        return
    fi

    if [ -n "$abort" ]; then
        splice_abort
        return
    fi

    # Handle both normal execution and --continue
    splice
}

splice () {
    base="$(<$base_file)"
    branch="$(<$branch_file)"
    if [ -e "$insert_todo" ]; then
        insert_range=( "$(<$insert_todo)" )
    fi

    validate_base

    if valid_ref "$TMP_BRANCH"; then
        if ! on_tmp_branch; then
            echo git checkout -q "$TMP_BRANCH"
            git checkout -q "$TMP_BRANCH"
        fi
    else
        echo git checkout -q -B "$TMP_BRANCH" "$base"
        git checkout -q -B "$TMP_BRANCH" "$base"
    fi

    if [ "${#insert_range[@]}" -ge 1 ]; then
        if valid_ref CHERRY_PICK_HEAD; then
            args=( --continue )
        else
            args=( "${insert_range[@]}" )
        fi

        echo git cherry-pick "${args[@]}"
        if ! git cherry-pick "${args[@]}"; then
            error_and_pause "git cherry-pick ${args[*]} failed!"
        fi

        rm "$insert_todo"
    fi

    if rebase_active; then
        args=( --continue )
    else
        args=( -i --onto "$TMP_BRANCH" "$base" "$branch" )
    fi

    echo git rebase "${args[@]}"
    if ! VISUAL="$0 $debug --rebase-edit" git rebase "${args[@]}"; then
        error_and_pause "git rebase ${args[*]} failed!"
    fi

    git branch -d "$TMP_BRANCH"
    rm -rf "$splice_dir"
}

valid_ref () {
    git rev-parse --quiet --verify "$@" >/dev/null
}

rebase_active () {
    [ -e "$git_dir/rebase-merge" ]
}

validate_base () {
    if [ -z "$base" ]; then
        abort "BUG: base should not be empty"
    fi

    if ! valid_ref "$base"; then
        cleanup
        abort "Base commit $base was not valid"
    fi
}

error_and_pause () {
    warn "$*"
    warn "Please fix manually and run git splice --continue,"
    warn "or run git splice --abort to abandon the splice."
    exit 1
}

cleanup () {
    aborted=

    if [ -e "$insert_todo" ]; then
        if valid_ref CHERRY_PICK_HEAD; then
            git cherry-pick --abort
        fi

        rm "$insert_todo"
        aborted=y
    fi

    if [ -e "$remove_todo" ]; then
        if rebase_active; then
            git rebase --abort
        fi

        rm "$remove_todo"
        aborted=y
    fi

    if valid_ref "$TMP_BRANCH"; then
        if on_tmp_branch; then
            git checkout "$(<$branch_file)"
        fi

        git branch -d "$TMP_BRANCH"
        aborted=y
    fi

    if [ -d "$splice_dir" ]; then
        rm -rf "$splice_dir"
        aborted=y
    fi
}

splice_abort () {
    cleanup

    if [ -z "$aborted" ]; then
        abort "No splice in progress"
    fi
}

head_ref () {
    git symbolic-ref --short -q HEAD
}

on_tmp_branch () {
    [ "`head_ref`" = "$TMP_BRANCH" ]
}

ensure_splice_in_progress () {
    if ! [ -d "$splice_dir" ] && ! on_tmp_branch; then
        abort "Splice not in progress"
    fi
}

ensure_splice_not_in_progress () {
    for file in "$insert_todo" "$remove_todo"; do
        if [ -e "$file" ]; then
            in_progress_error "$file already exists."
        fi
    done

    ensure_rebase_not_in_progress

    if on_tmp_branch; then
        in_progress_error "Already on $TMP_BRANCH branch."
    fi
}

in_progress_error () {
    cat <<EOF >&2
$*

git splice already in progress; please complete it, or run

  git splice --abort
EOF
    exit 1
}

ensure_rebase_not_in_progress () {
    if rebase_active; then
        warn "Can't start git splice when there is a rebase in progress."

        # We know this will fail; we run it because we want to output
        # the same error message which git-rebase uses to tell the user
        # to finish or abort their in-flight rebase.
        git rebase
        exit 1
    fi
}

rebase_edit () {
    if ! [ -e "$rebase_todo" ]; then
        abort "BUG: $me invoked in rebase edit mode, but $rebase_todo was missing"
    fi

    if [ -e "$remove_todo" ]; then
        grep -v -f "$remove_todo" "$rebase_todo" > "$rebase_todo".new
        mv "$rebase_todo".new "$rebase_todo"
    fi
}

warn () {
    echo >&2 "$*"
}

die () {
    echo >&2 "$*"
    exit 1
}

abort () {
    die "$*; aborting."
}

usage () {
    # Call as: usage [EXITCODE] [USAGE MESSAGE]
    exit_code=1
    if [[ "$1" == [0-9] ]]; then
        exit_code="$1"
        shift
    fi

    cat <<EOF >&2
Usage:
  $me REMOVE-RANGE
  $me REMOVE-RANGE CHERRY-PICK-RANGE
  $me INSERTION-POINT CHERRY-PICK-RANGE
  $me REMOVE-RANGE-ARGS ... -- CHERRY-PICK-RANGE-ARGS ...
  $me OPTIONS

Options:
  -h, --help      Show this help and exit
      --abort     Abort an in-progress splice
      --continue  Continue an in-progress splice

REMOVE-RANGE and CHERRY-PICK-RANGE are single shell words specifying
commit ranges in the standard format accepted by "git rev-parse", e.g.

  A..B
  A...B
  A^!   (just commit A)

INSERTION-POINT is a commitish in the standard format accepted
by "git rev-parse".

REMOVE-RANGE specifies the range of commits to remove from the current
branch, and CHERRY-PICK-RANGE specifies the range to insert at the
point where REMOVE-RANGE previously existed, or just after
INSERTION-POINT.

It is possible to pass multi-word specifications for both the removal
and insertion ranges, in which case they are passed to "git rev-list"
to calculate the commits to remove or cherry-pick.  For this you need
to terminate REMOVE-RANGE-ARGS with "--", e.g.

  # remove all commits since 11am this morning mentioning "foo"
  git splice --since=11am --grep="foo" --
EOF

    if [ -n "$1" ]; then
        echo >&2
        echo >&2 "ERROR: $*"
    fi

    exit "$exit_code"
}

parse_opts () {
    while [ $# != 0 ]; do
        case "$1" in
            -h|--help)
                usage 0
                ;;
            -v|--version)
                echo "$me $VERSION"
                ;;
            -d|--debug)
                debug=--debug
                set -x
                shift
                ;;
            --continue)
                continue=yes
                shift
                ;;
            --abort)
                abort=yes
                shift
                ;;
            # for internal use only
            --rebase-edit)
                rebase_edit=yes
                rebase_todo="$2"
                shift 2
                ;;
            -*)
                usage "Unrecognised option: $1"
                ;;
            *)
                break
                ;;
        esac
    done

    ARGV=( "$@" )
}

parse_args () {
    if [ -n "$abort" ] || [ -n "$continue" ] || [ -n "$rebase_edit" ]; then
        return
    fi

    count=$#
    for word in "$@"; do
        if [ "$word" = '--' ]; then
            multi_word=yes
            count=$(( count - 1 ))
            break
        fi
    done

    if [ $count -eq 0 ]; then
        usage "You must specify at least one range to remove or insert."
    fi

    if [ -z "$multi_word" ]; then
        if [ $# -ge 1 ]; then
            remove_range_or_insertion_base=( "$1" )
        fi

        if [ $# -eq 2 ]; then
            insert_range=( "$2" )
        elif [ $# -ge 2 ]; then
            usage "Use of multiple words in the removal or insertion" \
                  "ranges requires the -- separator"
        fi
    else
        remove_range_or_insertion_base=()
        for word in "$@"; do
            if [ "$word" = '--' ]; then
                shift
                insert_range=( "$@" )
                break
            fi
            remove_range_or_insertion_base+=( "$word" )
            shift
        done
    fi

    if ! parsed=(
            `git rev-parse "${remove_range_or_insertion_base[@]}" 2>/dev/null`
        )
    then
        cleanup
        abort "Failed to parse ${remove_range_or_insertion_base[*]}"
    fi

    if ! head_ref > "$branch_file"; then
        rm "$branch_file"
        abort "Cannot run $me on detached head"
    fi

    if [ "${#parsed[@]}" -eq 1 ]; then
        : must be an insertion point
        insertion_point="$parsed"
        if [ "${#insert_range[@]}" -eq 0 ]; then
            usage "You provided an insertion point but no range to cherry-pick."
        fi
        echo "$insertion_point" >"$base_file"
    else
        : must be a removal range
        remove_range=( "${remove_range_or_insertion_base[@]}" )
        git rev-list --abbrev-commit "${remove_range[@]}" | \
            sed 's/^/pick /' >"$remove_todo"
        tail -n1 "$remove_todo" | sed 's/^pick \(.\+\)/\1^/' >"$base_file"
    fi

    if [ "${#insert_range[@]}" -gt 0 ]; then
        if ! valid_ref "${insert_range[@]}"; then
            cleanup
            abort "Failed to parse ${insert_range[*]}"
        fi
        echo "${insert_range[@]}" >"$insert_todo"
    fi
}

main "$@"
