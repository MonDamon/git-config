#!/usr/bin/ruby
#
# Some extra icing on top of git cherry's tasty cake ...
#
#   - Allow blacklisting of commits which should never be upstreamed,
#     via the git-notes(1) mechanism.  To blacklist a commit from being
#     upstreamed to any branch:
#
#         git notes --ref=upstreaming add -m'skip: all' $sha
#
#     or to blacklist from being upstreamed to specific branches (currently
#     only works when the upstream branch is explicitly provided):
#
#         git notes --ref=upstreaming add    -m'skip: upstream-branch' $sha
#         git notes --ref=upstreaming append -m'skip: another-branch'  $sha
#         git notes --ref=upstreaming append -m'skip: /branch-regexp/' $sha
#
#     It is strongly recommended that you also include justification for
#     why this commit should not be upstreamed.  You can place free-form
#     text in the note, as long as the 'skip: ' line is preserved, with
#     no indentation.  To edit the note:
#
#         git notes --ref=upstreaming edit $sha
#
#     To remove from the blacklist:
#
#         git notes --ref=upstreaming remove $sha
#
#     To push / pull the blacklist notes between git repositories, see:
#
#         http://stackoverflow.com/questions/12055303/merging-git-notes-when-there-are-merge-conflicts-in-them/
#
#   - colour-code commits:
#
#      - green  means already upstream
#      - red    means not yet upstream
#      - grey   means should not be pushed to this upstream
#      - yellow means not yet upstream and has unparseable note
#      - blue   means         upstream and has unparseable note

require 'optparse'
require 'open3'
require 'shellwords'

# This would make the code nicer, but let's minimise dependencies instead ...
# require 'term/ansicolor'
# include Term::ANSIColor

$verbosity = 0
$summary = false

def output(level, colour, msg)
  if level <= $verbosity
    msg = "\033[#{colour}m#{msg}\033[0m" if colour && STDOUT.tty?
    puts msg
  end
end

def upstreaming_note(sha)
  ENV['LANG'] = 'C'
  cmd = [ 'git', 'notes', '--ref=upstreaming', 'show', sha ]
  out = nil
  Open3.popen3(*cmd) do |stdin, stdout, stderr, wait_thread|
    out = stdout.readlines().join('')
    err = stderr.readlines().join('')
    status = wait_thread.value
    return nil if err =~ /No note found for object/
    unless status.success?
      raise cmd.shelljoin + " exited with status #{status.exitstatus}: #{err}"
    end
    unless err.empty?
      raise cmd.shelljoin + " outputted to STDERR: #{err}"
    end
  end
  out
end

def blacklisted(note, upstream_branch)
  skippers = note.split("\n").grep(/^skip: (.+?)\s*$/m) { |x| $1 }
  for skipper in skippers
    return true if skipper == 'all'
    if upstream_branch
      skipper = Regexp.new($1) if skipper =~ %r{^/(.+)/$}
      return true if skipper === upstream_branch
    end
  end
  false
end

def parse_options
  OptionParser.new do |opts|
    opts.banner = "usage: git cherry-icing [options] [git cherry args]\n\n"
    opts.on("-v", "--verbosity [N]", Integer, "Set verbosity level") do |verbosity|
      $verbosity = verbosity || 1
    end
    opts.on("-s", "--summary", Integer, "Show summary") do
      $summary = true
    end
  end.parse!
end

def cherry(upstream_branch)
  totals = Hash.new(0)

  IO.popen(["git", "cherry", "-v"] + ARGV) do |out|
    out.each_line do |line|
      line.chomp!
      case line
      when /^- ([0-9a-f]{32})/
        # An equivalent change with the same patch-id is already upstream
        sha = $1
        note = upstreaming_note(sha)
        if note
          if blacklisted(note, upstream_branch)
            # Upstream *and* blacklisted?!  Treat as an error.
            line[0] = '.?'
            output 0, "1;30", line
          elsif note =~ /\bTODO\b/
            # Upstream *and* marked as a TODO?  Treat as an error.
            line[0] = '!?'
            output 1, "1;30", line
          else
            line[0] = '# '
            output 2, "36", line
          end
        else
          line[0] = '- '
          output 2, "32", line
        end
      when /^\+ ([0-9a-f]{32})/
        # Not upstream yet
        sha = $1
        note = upstreaming_note(sha)
        if note
          if blacklisted(note, upstream_branch)
            # We never want to upstream this
            line[0] = '. '
            output 1, "1;30", line
          elsif note =~ /\bTODO\b/
            # Not upstream but tracked on a TODO list elsewhere
            line[0] = '! '
            output 0, "35", line
          else
            # Note had unrecognised format
            line[0] = '? '
            output 1, "33", line
          end
        else
          # Not upstream and no note
          line[0] = '+ '
          output 0, "31", line
        end
      else
        # Unrecognised output; leave alone
        puts line
      end
      totals[line[0..1].strip] += 1
    end
  end

  exitcode = $?.exitstatus
  exit(exitcode) unless exitcode == 0

  return totals
end

def status_description(status)
  case status
  when '-', '#'
    "already upstream"
  when '.'
    "blacklisted"
  when '+'
    "not yet upstream"
  when '!'
      "TODO"
  when /^.\?$/
    "issue with note"
  else
    raise "unrecognised status '#{status}'"
  end
end

def needs_work?(status)
  case status
  when '-', '.'
    false
  when '+', '!', /^.\?$/
    true
  else
    raise "unrecognised status '#{status}'"
  end
end

def show_summary(totals)
  remaining, done = totals.sort_by { |status, count| -count }.partition {|t| needs_work?(t[0])}
  totals['done']      = done     .inject(0) { |acc, new| acc += new[1] }
  totals['remaining'] = remaining.inject(0) { |acc, new| acc += new[1] }
  total = totals['done'] + totals['remaining']
  percent = totals['done'].to_f / total * 100

  puts <<EOF
Summary
=======

#{totals['done']} commits processed:
EOF
  done.each do |status, count|
    puts "  %4d %2s" % [count, status_description(status)]
  end

  puts <<EOF

#{totals['remaining']} commits remaining:
EOF
  remaining.each do |status, count|
    puts "  %4d %2s" % [count, status_description(status)]
  end
  

  puts <<EOF % [totals['done'], total, percent]

Progress: %d / %d commits (%d%%)
EOF
end

def main
  parse_options
  upstream_branch = ARGV[0]

  trap "PIPE" do
    exit 1
  end

  totals = cherry(upstream_branch)
  if $summary
    puts
    show_summary(totals)
  end
end

main
